Angular is a powerful front-end framework that allows developers to create robust web applications. Angular is based on the Model-View-Controller (MVC) architecture and allows for the creation of reusable components, efficient state management, and two-way data binding. 

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HelloComponent } from './hello.component';

export const AppModule = NgModule({
  declarations: [HelloComponent],
  imports: [BrowserModule],
  bootstrap: [HelloComponent]
})
.class({
  constructor: function () {}
});

explantion for the above code 

üîç Explanation of Each Term
‚úÖ import { NgModule } from '@angular/core';
- Purpose: Imports the NgModule decorator from Angular's core library.
- What it does: NgModule is used to define an Angular module‚Äîa container for components, directives, pipes, and services.
- Why it's needed: Angular uses modules to organize and bootstrap the application.

‚úÖ import { BrowserModule } from '@angular/platform-browser';
- Purpose: Imports the BrowserModule, which is required to run Angular apps in a web browser.
- What it includes:
- Common directives like ngIf, ngFor
- DOM rendering capabilities
- Why it's needed: Without BrowserModule, Angular can't render components in the browser.

‚úÖ import { HelloComponent } from './hello.component';
- Purpose: Imports the HelloComponent that you created.
- What it does: Makes the component available to be declared and used in the module.
- Why it's needed: Angular modules must explicitly declare components they use.

‚úÖ export const AppModule = NgModule({...}).class({...});
This is how you define a module in JavaScript (instead of TypeScript).
üî∏ NgModule({...})
- Decorator function that takes a configuration object.
- It tells Angular how to compile and run the module.
üî∏ Configuration Object
{
  declarations: [HelloComponent],
  imports: [BrowserModule],
  bootstrap: [HelloComponent]
}


Let‚Äôs break down each key:

üß± declarations: [HelloComponent]
- Purpose: Declares the components, directives, and pipes that belong to this module.
- Why it's needed: Angular needs to know what components are part of this module so it can compile them.

üì• imports: [BrowserModule]
- Purpose: Imports other modules that this module depends on.
- Why it's needed: BrowserModule provides essential services and directives for browser-based apps.

üöÄ bootstrap: [HelloComponent]
- Purpose: Specifies the root component that Angular should bootstrap when starting the app.
- Why it's needed: This is the entry point of your application‚ÄîAngular renders this component first.

üß† .class({ constructor: function () {} })
- Purpose: Defines the class for the module using JavaScript syntax.
- Why it's needed: Angular modules are classes, and this syntax is how you define one in JavaScript.

üß© Summary Table
| Term | Role in Angular Module | 
| NgModule | Decorator to define a module | 
| BrowserModule | Enables Angular to run in the browser | 
| HelloComponent | A declared component used in the module | 
| declarations | Registers components, directives, pipes | 
| imports | Brings in other modules | 
| bootstrap | Specifies the root component to launch | 
| .class({}) | Defines the module class in JavaScript 


COMPONENTS
--------------
components are declared separately using the @ component annotation
ex|
@Component({
  selector: 'app-hello',
  template: `<h1>Hello from Angular!</h1>`
})

Component Structure
------------------------
The structure of an Angular component consists of three main parts:

Template: 
The template defines the HTML markup of the component's view. It contains placeholders and Angular directives that are replaced with dynamic data and logic during runtime.
Styles: 
The styles define the component's visual appearance, including CSS rules and stylesheets. Styles can be defined using inline styles, external CSS files, or CSS preprocessors like Sass or Less.
TypeScript Code:
 The TypeScript code defines the component's behavior and logic. It includes properties, methods, and lifecycle hooks that control how the component interacts with the DOM, handles user input, and responds to changes in its state or props.


Component Lifecycle
---------------------
Angular components have a lifecycle consisting of various lifecycle hooks that are executed at different stages of the component's lifecycle. These lifecycle hooks allow to hook into specific moments in the component's lifecycle and perform actions such as initialization, cleanup, or handling changes.

Some of the most commonly used lifecycle hooks include:
----------------------------------------

ngOnInit: Called after the component's inputs are initialized and the component's view has been initialized.
ngOnChanges: Called whenever the component's inputs change.
ngOnDestroy: Called when the component is being destroyed and cleaned up.
Data Binding
Data binding in Angular allows for communication between the component's TypeScript code and its template. There are three types of data binding in Angular:

One-Way Binding: Data flows from the component's TypeScript code to its template. Changes in the component's properties are reflected in the template, but changes in the template do not affect the component's properties.
Two-Way Binding: Data flows both ways between the component's TypeScript code and its template. Changes in the component's properties are reflected in the template, and changes in the template are propagated back to the component's properties.
Event Binding: Allows the template to listen for events triggered by the user or the browser and execute corresponding methods in the component's TypeScript code.
Input and Output Properties
Input properties allow data to be passed into a component from its parent component, while output properties allow a component to emit events to its parent component. Input properties are defined using the @Input decorator, while output properties are defined using the @Output decorator along with EventEmitter.

Component communication
Component communication in Angular involves passing data between components and coordinating their behavior. There are several methods for component communication:

Parent-Child Communication: Data can be passed from a parent component to a child component using input properties, and events can be emitted from the child component to the parent component using output properties.
Sibling Communication: Sibling components can communicate indirectly through their common parent component by passing data through input and output properties or using a shared service to store and exchange data.
Communication Between Unrelated Components: Components that are not directly related can communicate through a shared service. The shared service acts as a mediator, allowing components to exchange data and coordinate their behavior without having a direct relationship.



example for modules
--------------------

Great question! The **declarations** array in an Angular module is essential for telling Angular which components, directives, and pipes belong to that module. Without declaring them, Angular won‚Äôt know they exist or how to compile them.
Let‚Äôs break it down in detail:

üßæ What Is declarations in Angular?
‚úÖ Syntax
@NgModule({
  declarations: [MyComponent, MyDirective, MyPipe],
  imports: [...],
  bootstrap: [AppComponent]
})
export class AppModule {}


üìò Purpose
- The declarations array is used to register components, directives, and pipes that are part of the module.
- It tells Angular‚Äôs compiler: ‚ÄúThese are the things I want to use in my templates.‚Äù

üß© Why Is declarations Important?
üîç 1. Component Recognition
Angular needs to know about a component before it can render it in a template.



ANGULAR 2
---------
Angular 2 Architecture
Angular 2 follows a component-based architecture, breaking down applications into reusable components. Let‚Äôs explore the key components:

1. Modules:
Modules organize the application into smaller functional units.
Group related components, services, and directives within a module.
Load modules as needed, enhancing code organization and reusability.

2. Services:
Services facilitate data sharing and handle application logic.
Communicate with external APIs and manage critical functionality.
Share data across components seamlessly.

3. Directives:
Modify the behavior and appearance of HTML elements.
Create custom HTML tags and attributes for consistent use across the application.
Enhance the user interface by applying directives where needed.

4. Pipes:
Transform data before displaying it to users.
Use pipes for filtering, formatting, and sorting data.
Customize data presentation efficiently.

